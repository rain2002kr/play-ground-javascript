"use strict";
const log = (m) => console.log(m);
const clr = () => console.clear();
// 1. FUNCTION 
// 2. CLASS
// 3. OBJECT
// 4. ARRAY
// 5. JSON 

// 1. FUNCTION
    // 파라메터 디폴트파라메터, 리턴 , IIFE, 생성자 함수 , ...arg
    // 함수 네이밍 : doSometing, command, verb
    // 함수 프로그래밍시 조건 만족 안하면 바로빠져나가는 기능 
    // 익명 함수 
    // 구조화 프로그래밍 
    // 콜백 함수 
    // 화살표 함수 
    // 함수의 변수화, Return 원하는 변수, 함수

// 2. CLASS 
    // 클래스명 { constructor ... }
    // Getter 와 Setter 로 값의 입력 출력 오류 방지 
    // static 선언 으로 인스턴스 없이 그대로 사용 가능. 
    // 상속 으로 부모 클래스와 자식 클래스 생성 기능, 오버로딩 오버라이딩
    // instanceOf 로 클래스 확인 가능 
    // 데이터 클래스 , 

// 3. OBJECT
    // 키와 값으 쌍으로 구성 
    // Obeject 접근 : Obj.name , Obj['name']
    // Object 내장 함수 
        // OBJ.Assign, OBJ.keys, OBJ.values, OBJ.entryes
        // log(key in Obj) 로 키값 유무 확인 가능. 
        // OBJ.Assign : 복사 , 변경, 합체 가능. 

// 4. ARRAY 
    //  자료구조 VS 오브젝트 
    //  타입이 달라도 담을수 있지만 권장하지 않는다. 
    //  배열 내장 함수 
    //  push, pop, unshift, shift
    //  forEach, key of array
    //  join, split 
    //  sort, reverse
    //  slice, find, filter, map
    //  some, every, reduce 

//  5. JSON 
    //  OBJ -> JSON 
    //  함수나 symbol 같은 것은 안됨.
    //  JSON.stringfy(obj,[""])
    //  JSON.stringfy(obj,(key,value)=>{value==="key"?"":valeu})

    //  JSON -> OBJ
    //  함수나 symbol 같은 것은 리바이벌로 살려야함. 
    //  JSON.parse(obj)
    //  JSON.parse(obj,(key,value)=>{value==="key"?"":valeu})
    
    












